# -*- coding: utf-8 -*-
"""ANN_multi_in_out_iris.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nyr106S5nNlXQL58cdX_N5cVFzrqzULD

# Multi-Output ANN (IRIS Data Set)
"""

# Import Libraries
import numpy as np
import torch
import torch.nn as nn
import matplotlib.pyplot as plt
from IPython import display as dp
import sympy as sym
import matplotlib_inline.backend_inline
matplotlib_inline.backend_inline.set_matplotlib_formats('svg')

# Importing IRIS dataset
import seaborn as sns
iris = sns.load_dataset('iris')

# Checking the first line of the data:
iris.head()

# Data plotting
sns.pairplot(iris, hue='species')
plt.show()

# Organizing the data:
# Converting from pandas dataframe to tensor
data = torch.tensor(iris[iris.columns[0:4]].values).float()

# Transform species to number
labels = torch.zeros(len(data), dtype=torch.long) # Setosa set = 0
labels[iris.species.values== 'versicolor'] = 1 # Versicolor
labels[iris.species.values== 'virginica'] = 2 # Virginica

"""## Creating The Model"""

# Model Architecture
ANNiris = nn.Sequential(
    nn.Linear(4,64),      # Input Layer
    nn.ReLU(),            # Activation
    nn.Linear(64,64),     # Hidden Layer
    nn.ReLU(),            # Activation
    nn.Linear(64,3),      # Output Layer
)

# Loss Function
lossFunction = nn.CrossEntropyLoss()    # Soft Max is applied through this LF
                                        # So prob sums up to 1 accross 3 outputs
# Optimizer
optimizer = torch.optim.SGD(ANNiris.parameters(), lr=0.01)

"""## Training The Model"""

# Parameters
epochs = 1000

# Initializing losses
losses = torch.zeros(epochs)
acc = []

# Running the training
for i in range(epochs):
    # Predictions
    y_hat = ANNiris(data)
    # Loss
    loss = lossFunction(y_hat, labels)
    losses[i] = loss

    # Backprop
    optimizer.zero_grad()
    loss.backward()
    optimizer.step()

    # Computing Accuracy
    matches = torch.argmax(y_hat, axis=1) == labels   # Boolean False/True
    matchesNumeric = matches.float()                  # Convert to 0/1
    accuracy = 100*torch.mean(matchesNumeric)         # Convert to %
    acc.append(accuracy)                              # Append to list

# Final forward pass
predictions = ANNiris(data)
pred_labels = torch.argmax(predictions, axis=1)
total_acc = 100*torch.mean((pred_labels == labels).float())

# Visualizing Results
print(f'Total Accuracy: {total_acc}%')

fig, ax = plt.subplots(1,2, figsize=(13,4))
ax[0].plot(losses.detach(), 'r-')
ax[0].set_xlabel('Epochs')
ax[0].set_ylabel('Loss')

ax[1].plot(acc, 'b-')
ax[1].set_xlabel('Epochs')
ax[1].set_ylabel('Accuracy')
plt.show()

# Plotting Raw Model Outputs:
fig = plt.figure(figsize=(10,4))

plt.plot(nn.Softmax(dim=1)(y_hat).detach(), 's-', markerfacecolor='w')
plt.xlabel('Samples')
plt.ylabel('Probability')
plt.legend(['Setosa', 'Versicolor', 'Virginica'])
plt.show()